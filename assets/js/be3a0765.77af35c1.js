"use strict";(self.webpackChunkexplorer_course=self.webpackChunkexplorer_course||[]).push([[5863],{3905:(e,a,n)=>{n.d(a,{Zo:()=>u,kt:()=>d});var o=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function t(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);a&&(o=o.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?t(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,o,r=function(e,a){if(null==e)return{};var n,o,r={},t=Object.keys(e);for(o=0;o<t.length;o++)n=t[o],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(o=0;o<t.length;o++)n=t[o],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),i=function(e){var a=o.useContext(c),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},u=function(e){var a=i(e.components);return o.createElement(c.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return o.createElement(o.Fragment,{},a)}},p=o.forwardRef((function(e,a){var n=e.components,r=e.mdxType,t=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=i(n),d=r,f=p["".concat(c,".").concat(d)]||p[d]||m[d]||t;return n?o.createElement(f,s(s({ref:a},u),{},{components:n})):o.createElement(f,s({ref:a},u))}));function d(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var t=n.length,s=new Array(t);s[0]=p;var l={};for(var c in a)hasOwnProperty.call(a,c)&&(l[c]=a[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var i=2;i<t;i++)s[i]=n[i];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3959:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>t,metadata:()=>l,toc:()=>i});var o=n(7462),r=(n(7294),n(3905));const t={sidebar_position:10},s="Asincronismo",l={unversionedId:"tutorial-js/asincronismo",id:"tutorial-js/asincronismo",title:"Asincronismo",description:"Fundamentos del Asincronismo",source:"@site/docs/tutorial-js/asincronismo.md",sourceDirName:"tutorial-js",slug:"/tutorial-js/asincronismo",permalink:"/explorer-course-ai/docs/tutorial-js/asincronismo",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Objetos",permalink:"/explorer-course-ai/docs/tutorial-js/objetos"},next:{title:"HTML - CSS",permalink:"/explorer-course-ai/docs/category/html---css"}},c={},i=[{value:"Asincronismo vs sincronismo",id:"asincronismo-vs-sincronismo",level:2},{value:"Conceptos",id:"conceptos",level:2},{value:"Callback",id:"callback",level:3},{value:"Promesas",id:"promesas",level:3},{value:"Async / Await",id:"async--await",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2}],u={toc:i};function m(e){let{components:a,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"asincronismo"},"Asincronismo"),(0,r.kt)("p",null,"Fundamentos del ",(0,r.kt)("strong",{parentName:"p"},"Asincronismo")),(0,r.kt)("h2",{id:"asincronismo-vs-sincronismo"},"Asincronismo vs sincronismo"),(0,r.kt)("p",null,"Cuando hablamos de internet hablamos de informaci\xf3n, est\xe1 informaci\xf3n tarda en transportarse de un lugar a otro, por ejemplo cuando visitas una p\xe1gina web esta normalmente\nse demora un poco en cargar, en ocasiones el retardo es casi imperceptible y en otras no tanto. Esto se puede deber a varias razones, una de ellas es que la informaci\xf3n almacenada\nen diferentes servidores tarda en llegar al DOM. Javascript al ser el lenguaje de la Web deb\xedo en su momento considerar esto y nos proporcion\xf3 herramientas para manejar estos\nretardos, aunque la palabra t\xe9cnica sea programaci\xf3n asincr\xf3nica, hasta este momento en el m\xf3dulo de Javascript hemos realizado programaci\xf3n sincr\xf3nica."),(0,r.kt)("h2",{id:"conceptos"},"Conceptos"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Concurrencia: cuando dos o mas tareas progresan simult\xe1neamente."),(0,r.kt)("li",{parentName:"ul"},"Paralelismo: cuando dos o mas tareas se ejecutan, literalmente, a la vez, en el mismo instante de tiempo."),(0,r.kt)("li",{parentName:"ul"},"S\xedncrono: el programa se ejecuta linea a linea, instrucci\xf3n por instrucci\xf3n, hasta que no se concluya la actual no se sigue a la siguiente. "),(0,r.kt)("li",{parentName:"ul"},"As\xedncrono: la finalizaci\xf3n de la operaci\xf3n se realiza m\xe1s tarde, mediante un mecanismo espec\xedfico como por ejemplo un callback, una promesa o un evento (se explicar\xe1n\ndespu\xe9s), lo que hace posible que la respuesta sea procesada en diferido. Como se puede adivinar, su comportamiento es no bloqueante ya que la instrucci\xf3n no se\ntermina de ejecutar inmediatamente, pero se sigue a la siguiente instrucci\xf3n.")),(0,r.kt)("h3",{id:"callback"},"Callback"),(0,r.kt)("p",null,'Una funci\xf3n callback es aquella que es pasada como argumento a otra funci\xf3n para que sea "llamada de nuevo" (call back) en un momento posterior. Una funci\xf3n que acepta otras funciones como argumentos es llamada funci\xf3n de orden-superior (High-Order), y contiene la l\xf3gica para determinar cu\xe1ndo se ejecuta la funci\xf3n callback. Es la combinaci\xf3n de estas dos la que nos permite ampliar nuestra funcionalidad.'),(0,r.kt)("p",null,"Ejemplo: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'setTimeout(function(){\n  console.log("Hola Mundo con retraso!");\n}, 1000)\n')),(0,r.kt)("p",null,"En el anterior ejemplo tenemos la una funci\xf3n propia de Javascript llamada ",(0,r.kt)("inlineCode",{parentName:"p"},"setTimeout")," que es una funci\xf3n asincrona que recibe como parametro una funci\xf3n, b\xe1sicamente lo que hace ",(0,r.kt)("inlineCode",{parentName:"p"},"setTimeout")," es ejecutar la funcion que le pasamos por parametro luego de esperar los milisegundos pasados como segundo par\xe1metro. Tambi\xe9n lo podemos almacenar la funcion que pasamos por par\xe1metro en una variable as\xed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'const myCallback = () => console.log("Hola Mundo con retraso!");\nsetTimeout(myCallback, 1000);\n')),(0,r.kt)("p",null,"Ahora bien, \xbfC\xfaal es el problema de los callbacks? Los problemas comienzan cuando tenemos varios callbacks anidados, convirtiendo nuestro c\xf3digo complicado de leer. Por ejemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'setTimeout(function(){\n  console.log("Etapa 1 completada");\n  setTimeout(function(){\n    console.log("Etapa 2 completada");\n    setTimeout(function(){\n      console.log("Etapa 3 completada");\n      setTimeout(function(){\n        console.log("Etapa 4 completada");\n        // Podr\xedamos continuar hasta el infinito...\n      }, 4000);\n    }, 3000);\n  }, 2000);\n}, 1000);\n')),(0,r.kt)("h3",{id:"promesas"},"Promesas"),(0,r.kt)("p",null,"Una promesa es un objeto que representa el resultado de una operaci\xf3n as\xedncrona. Este resultado podr\xeda estar disponible ahora o en el futuro. Las promesas se basan en callbacks pero tienen un mejor manejo y sintaxis. Las promesas son especiales en t\xe9rminos de asincron\xeda ya que a\xf1aden un nuevo nivel de prioridad que estudiaremos a continuaci\xf3n."),(0,r.kt)("p",null,"Cuando llamamos a una funci\xf3n as\xedncrona implementada con este patr\xf3n, nos devolver\xe1 inmediatamente una promesa como garant\xeda de que la operaci\xf3n as\xedncrona finalizar\xe1 en alg\xfan momento, ya sea con \xe9xito o con fallo. Una vez que tengamos el objeto promesa en nuestro poder, registramos un par de callbacks: uno para indicarle a la promesa 'que debe hacer en caso de que todo vaya bien' (resoluci\xf3n de la promesa o resolve) y otro para determinar 'que hacer en caso de fallo' (rechazo de la promesa o reject)."),(0,r.kt)("p",null,"A resumidas cuentas, una promesa es un objeto al que le adjuntamos callbacks, en lugar de pasarlos directamente a la funci\xf3n as\xedncrona. La forma en que registramos esos dos callbacks es mediante el m\xe9todo .then(resolveCallback, rejectCallback). En terminolog\xeda de promesas, decimos que una promesa se resuelve con \xe9xito (resolved) o se rechaza con fallo (rejected)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fetch(document.URL.toString())\n  .then(result => console.log(result),\n    e => console.log(`Error capturado:  ${e}`));\n")),(0,r.kt)("p",null,"Una caracter\xedstica interesante de las promesas es que pueden ser encadenadas. Esto es posible gracias a que la llamada .then() tambi\xe9n devuelve una promesa. Esta nueva promesa devuelta ser\xe1 resuelta con el valor que retorne el callback de resoluci\xf3n original (el que hemos pasado al primer then()):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'fetch(document.URL.toString())\n  .then(result => {\n    console.log(result);\n    return "Primer Then";\n  },\n    e => console.log(`Error capturado:  ${e}`))\n  .then(result => console.log(`Segundo Then despues de ${result}: La p\xe1gina ya ha debido ser mostrada`),\n    e => console.log(`Error capturado:  ${e}`));\n')),(0,r.kt)("p",null,"Para evitar verbosidad, podemos encadenar las promesas de un modo mas corto, empleando el m\xe9todo .catch(rejectCallback) para catpurar cualquier rechazo que ocurra en cualesquiera de las promesas encadenadas. catch(rejectCallback) es equivalente a .then(null, rejectCallback). Solo se necesita una \xfanica sentencia catch() al final de una cadena de promesas:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fetch(document.URL.toString())\n  .then(result => console.log(result))\n  .then(() => console.log(`Fetch completado, p\xe1gina mostrada`))\n  .catch(e => console.log(`Error capturado:  ${e}`));\n")),(0,r.kt)("p",null,"En el ejemplo anterior, pedimos al servidor que nos provea una URL utilizando la funci\xf3n as\xedncrona fetch y nos devuelve una promesa. Configuramos la promesa con dos callbacks: uno para resolver la promesa, que mostrar\xe1 la p\xe1gina por consola en caso de \xe9xito, y otro para rechazarla en caso de fallo que mostrar\xe1 el error asociado."),(0,r.kt)("p",null,"Cuando tenemos varias promesas y queremos que se resuelvan todas podemos hacerlo como en el siguiente ejemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'const p1 = fetch("URL1_Aqui");\nconst p2 = fetch("URL2_Aqui");\nconst p3 = fetch("URL3_Aqui");\n\nPromise.all([p1, p2, p3])\n  .then(resultArray => console.log(resultArray))\n  .catch(e => console.log(`Error capturado:  ${e}`));\n')),(0,r.kt)("p",null,"Lo anterior es muy \xfatil al momento de querer realizar instrucciones asincronas dentro de estructuras como .map, .filter o foreach. "),(0,r.kt)("h3",{id:"async--await"},"Async / Await"),(0,r.kt)("p",null,"Las promesas supusieron un gran salto en Javascript al introducir una mejora sustancial sobre los callbacks y un manejo m\xe1s elegante de nuestras tareas as\xedncronas. Sin embargo, tambi\xe9n pueden llegar a ser tediosas y verbosas a medida que se requieren m\xe1s y m\xe1s .then(). Las palabras clave async y await surgieron para simplificar el manejo de las promesas. Son puro az\xfacar para hacer las promesas m\xe1s amigables, escribir c\xf3digo m\xe1s sencillo, reducir el anidamiento y mejorar la trazabilidad al depurar. Pero recuerda, async \\ await y las promesas son lo mismo en el fondo."),(0,r.kt)("p",null,"La etiqueta async declara una funci\xf3n como as\xedncrona e indica que una promesa ser\xe1 autom\xe1ticamente devuelta. Podemos declarar como async tanto funciones con nombre, an\xf3nimas, o funciones flecha. Por otro lado, await debe ser usado siempre dentro de una funci\xf3n declarada como async y esperar\xe1 autom\xe1ticamente (de forma as\xedncrona y no bloqueante) a que una promesa se resuelva."),(0,r.kt)("p",null,"Ejemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'const checkServerWithSugar = async (url) => {\n  const response = await fetch(url);\n  return `Estado del Servidor: ${response.status === 200 ? "OK" : "NOT OK"}`;\n}\n\ncheckServerWithSugar(document.URL.toString())\n  .then(result => console.log(result))\n  .catch(e => console.log(`Error Capturado Fuera de la funci\xf3n async: ${e}`));\n')),(0,r.kt)("h2",{id:"m\xe1s-informaci\xf3n"},"M\xe1s informaci\xf3n"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://lemoncode.net/lemoncode-blog/2018/1/29/javascript-asincrono"},"https://lemoncode.net/lemoncode-blog/2018/1/29/javascript-asincrono")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://www.freecodecamp.org/espanol/news/que-es-una-funcion-callback-javascript/"},"https://www.freecodecamp.org/espanol/news/que-es-una-funcion-callback-javascript/")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://jonmircha.com/javascript-asincrono"},"https://jonmircha.com/javascript-asincrono"))))}m.isMDXComponent=!0}}]);